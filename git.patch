diff --git a/configure.ac b/configure.ac
index 0631bcc..123356c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -118,7 +118,15 @@ if test x$BUILD_VMWGFX = xyes; then
 	PKG_CHECK_MODULES([LIBDRM], [libdrm],[],[BUILD_VMWGFX=no])
 fi
 if test x$BUILD_VMWGFX = xyes; then
-	PKG_CHECK_MODULES([XATRACKER], [xatracker >= 0.4.0],[],[BUILD_VMWGFX=no])
+#
+# Early versions of mesa 10 forgot to bump the XA major version number in
+# the xa_tracker.h header
+#
+	PKG_CHECK_MODULES([XATRACKER], [xatracker >= 0.4.0],
+			  [PKG_CHECK_EXISTS([xatracker = 2.0.0],
+	                  [AC_DEFINE([HAVE_XA_2], 1,
+               		  [Has version 2 of XA])])],
+			  [],[BUILD_VMWGFX=no])
 fi
 
 DRIVER_NAME=vmware
diff --git a/src/vmware_bootstrap.c b/src/vmware_bootstrap.c
index ea5be19..bb58325 100644
--- a/src/vmware_bootstrap.c
+++ b/src/vmware_bootstrap.c
@@ -256,7 +256,6 @@ VMwarePciProbe (DriverPtr           drv,
                 intptr_t            match_data)
 {
     ScrnInfoPtr     scrn = NULL;
-    EntityInfoPtr   entity;
 
     scrn = xf86ConfigPciEntity(scrn, 0, entity_num, VMWAREPciChipsets,
                                NULL, NULL, NULL, NULL, NULL);
@@ -267,7 +266,6 @@ VMwarePciProbe (DriverPtr           drv,
         scrn->Probe = NULL;
     }
 
-    entity = xf86GetEntityInfo(entity_num);
     switch (DEVICE_ID(device)) {
     case PCI_DEVICE_ID_VMWARE_SVGA2:
     case PCI_DEVICE_ID_VMWARE_SVGA:
diff --git a/src/vmwarevideo.c b/src/vmwarevideo.c
index 745c71f..8d7d171 100644
--- a/src/vmwarevideo.c
+++ b/src/vmwarevideo.c
@@ -82,7 +82,7 @@
 #define VMWARE_VID_MAX_HEIGHT   2048
 
 #define VMWARE_VID_NUM_ENCODINGS 1
-static XF86VideoEncodingRec vmwareVideoEncodings[] =
+static const XF86VideoEncodingRec vmwareVideoEncodings[] =
 {
     {
        0,
@@ -108,7 +108,7 @@ static XF86ImageRec vmwareVideoImages[] =
 };
 
 #define VMWARE_VID_NUM_ATTRIBUTES 2
-static XF86AttributeRec vmwareVideoAttributes[] =
+static const XF86AttributeRec vmwareVideoAttributes[] =
 {
     {
         XvGettable | XvSettable,
diff --git a/vmwgfx/vmwgfx_dri2.c b/vmwgfx/vmwgfx_dri2.c
index 7de0772..4c74a6b 100644
--- a/vmwgfx/vmwgfx_dri2.c
+++ b/vmwgfx/vmwgfx_dri2.c
@@ -138,6 +138,8 @@ dri2_do_create_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer, unsigned int for
       return TRUE;
     case DRI2BufferStencil:
     case DRI2BufferDepthStencil:
+	if (!pScrn->vtSema)
+	    return FALSE;
 
 	depth = (format) ? vmwgfx_zs_format_to_depth(format) : 32;
 
@@ -155,6 +157,9 @@ dri2_do_create_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer, unsigned int for
 
        break;
     case DRI2BufferDepth:
+	if (!pScrn->vtSema)
+	    return FALSE;
+
 	depth = (format) ? vmwgfx_z_format_to_depth(format) :
 	    pDraw->bitsPerPixel;
 
@@ -201,7 +206,7 @@ dri2_do_create_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer, unsigned int for
     }
 
     private->srf = srf;
-    if (xa_surface_handle(srf, &buffer->name, &buffer->pitch) != 0)
+    if (_xa_surface_handle(srf, &buffer->name, &buffer->pitch) != 0)
 	return FALSE;
 
     buffer->cpp = xa_format_depth(xa_surface_format(srf)) / 8;
@@ -290,6 +295,14 @@ dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
     DrawablePtr dst_draw;
     RegionPtr myClip;
     GCPtr gc;
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+
+    /*
+     * This is a fragile protection against HW operations when not master.
+     * Needs to be blocked higher up in the dri2 code.
+     */
+    if (!pScrn->vtSema)
+	return;
 
     /*
      * In driCreateBuffers we dewrap windows into the
diff --git a/vmwgfx/vmwgfx_driver.c b/vmwgfx/vmwgfx_driver.c
index 7863ba2..4e28097 100644
--- a/vmwgfx/vmwgfx_driver.c
+++ b/vmwgfx/vmwgfx_driver.c
@@ -79,7 +79,7 @@ typedef uint8_t uint8;
 
 #define XA_VERSION_MINOR_REQUIRED 0
 #define XA_VERSION_MAJOR_REQUIRED 1
-#define XA_VERSION_MAJOR_COMPAT 1
+#define XA_VERSION_MAJOR_COMPAT 2
 
 #define DRM_VERSION_MAJOR_REQUIRED 2
 #define DRM_VERSION_MINOR_REQUIRED 3
@@ -617,7 +617,7 @@ vmwgfx_scanout_present(ScreenPtr pScreen, int drm_fd,
 	return FALSE;
     }
 
-    if (xa_surface_handle(vpix->hw, &handle, &dummy) != 0) {
+    if (_xa_surface_handle(vpix->hw, &handle, &dummy) != 0) {
 	LogMessage(X_ERROR, "Could not get present surface handle.\n");
 	return FALSE;
     }
@@ -657,7 +657,6 @@ void xorg_flush(ScreenPtr pScreen)
 	if (crtc->enabled) {
 	    pixmap = crtc_get_scanout(crtc);
 	    if (pixmap) {
-		unsigned int j;
 
 		/*
 		 * Remove duplicates.
@@ -1115,6 +1114,7 @@ drv_leave_vt(VT_FUNC_ARGS_DECL)
 
     vmwgfx_cursor_bypass(ms->fd, 0, 0);
     vmwgfx_disable_scanout(pScrn);
+    vmwgfx_saa_drop_master(pScrn->pScreen);
 
     if (drmDropMaster(ms->fd))
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
@@ -1135,6 +1135,8 @@ drv_enter_vt(VT_FUNC_ARGS_DECL)
     if (!drv_set_master(pScrn))
 	return FALSE;
 
+    vmwgfx_saa_set_master(pScrn->pScreen);
+
     if (!xf86SetDesiredModes(pScrn))
 	return FALSE;
 
diff --git a/vmwgfx/vmwgfx_output.c b/vmwgfx/vmwgfx_output.c
index 4f52f1d..f9e4263 100644
--- a/vmwgfx/vmwgfx_output.c
+++ b/vmwgfx/vmwgfx_output.c
@@ -60,7 +60,7 @@ struct output_private
     Bool is_implicit;
 };
 
-static char *output_enum_list[] = {
+static const char *output_enum_list[] = {
     "Unknown",
     "VGA",
     "DVI",
diff --git a/vmwgfx/vmwgfx_overlay.c b/vmwgfx/vmwgfx_overlay.c
index 6624a10..986dd06 100644
--- a/vmwgfx/vmwgfx_overlay.c
+++ b/vmwgfx/vmwgfx_overlay.c
@@ -84,7 +84,7 @@ typedef uint8_t uint8;
 #define VMWARE_VID_MAX_HEIGHT   2048
 
 #define VMWARE_VID_NUM_ENCODINGS 1
-static XF86VideoEncodingRec vmwareVideoEncodings[] =
+static const XF86VideoEncodingRec vmwareVideoEncodings[] =
 {
     {
        0,
@@ -110,7 +110,7 @@ static XF86ImageRec vmwareVideoImages[] =
 };
 
 #define VMWARE_VID_NUM_ATTRIBUTES 2
-static XF86AttributeRec vmwareVideoAttributes[] =
+static const XF86AttributeRec vmwareVideoAttributes[] =
 {
     {
         XvGettable | XvSettable,
diff --git a/vmwgfx/vmwgfx_saa.c b/vmwgfx/vmwgfx_saa.c
index 63df3a1..e76bd09 100644
--- a/vmwgfx/vmwgfx_saa.c
+++ b/vmwgfx/vmwgfx_saa.c
@@ -26,6 +26,7 @@
  */
 
 #include <xorg-server.h>
+#include <xorgVersion.h>
 #include <mi.h>
 #include <fb.h>
 #include <xf86drmMode.h>
@@ -76,7 +77,12 @@ vmwgfx_pixmap_remove_damage(PixmapPtr pixmap)
     if (!spix->damage || vpix->hw || vpix->gmr || vpix->malloc)
 	return;
 
+#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,14,99,2,0)
+    DamageUnregister(spix->damage);
+#else
     DamageUnregister(&pixmap->drawable, spix->damage);
+#endif
+
     DamageDestroy(spix->damage);
     spix->damage = NULL;
 }
@@ -286,7 +292,7 @@ vmwgfx_saa_dma(struct vmwgfx_saa *vsaa,
     if (vpix->gmr && vsaa->can_optimize_dma) {
 	uint32_t handle, dummy;
 
-	if (xa_surface_handle(vpix->hw, &handle, &dummy) != 0)
+	if (_xa_surface_handle(vpix->hw, &handle, &dummy) != 0)
 	    goto out_err;
 	if (vmwgfx_dma(0, 0, reg, vpix->gmr, pixmap->devKind, handle,
 		       to_hw) != 0)
@@ -305,6 +311,8 @@ vmwgfx_saa_dma(struct vmwgfx_saa *vsaa,
 			     (int) to_hw,
 			     (struct xa_box *) REGION_RECTS(reg),
 			     REGION_NUM_RECTS(reg));
+	if (to_hw)
+	    xa_context_flush(vsaa->xa_ctx);
 	if (vpix->gmr)
 	    vmwgfx_dmabuf_unmap(vpix->gmr);
 	if (ret)
@@ -420,6 +428,7 @@ vmwgfx_create_pixmap(struct saa_driver *driver, struct saa_pixmap *spix,
 
     WSBMINITLISTHEAD(&vpix->sync_x_head);
     WSBMINITLISTHEAD(&vpix->scanout_list);
+    WSBMINITLISTHEAD(&vpix->pixmap_list);
 
     return TRUE;
 }
@@ -496,6 +505,7 @@ vmwgfx_destroy_pixmap(struct saa_driver *driver, PixmapPtr pixmap)
      */
 
     vmwgfx_pixmap_remove_present(vpix);
+    WSBMLISTDELINIT(&vpix->pixmap_list);
     WSBMLISTDELINIT(&vpix->sync_x_head);
 
     if (vpix->hw_is_dri2_fronts)
@@ -624,6 +634,8 @@ vmwgfx_modify_pixmap_header (PixmapPtr pixmap, int w, int h, int depth,
 			     int bpp, int devkind, void *pixdata)
 {
     struct vmwgfx_saa_pixmap *vpix = vmwgfx_saa_pixmap(pixmap);
+    ScreenPtr pScreen = pixmap->drawable.pScreen;
+    struct vmwgfx_saa *vsaa = to_vmwgfx_saa(saa_get_driver(pScreen));
     unsigned int old_height;
     unsigned int old_width;
     unsigned int old_pitch;
@@ -667,6 +679,8 @@ vmwgfx_modify_pixmap_header (PixmapPtr pixmap, int w, int h, int depth,
 
     vmwgfx_pix_resize(pixmap, old_pitch, old_height, old_width);
     vmwgfx_pixmap_free_storage(vpix);
+    WSBMLISTADDTAIL(&vpix->pixmap_list, &vsaa->pixmaps);
+
     return TRUE;
 
   out_no_modify:
@@ -683,7 +697,7 @@ vmwgfx_present_prepare(struct vmwgfx_saa *vsaa,
 
     (void) pScreen;
     if (src_vpix == dst_vpix || !src_vpix->hw ||
-	xa_surface_handle(src_vpix->hw, &vsaa->src_handle, &dummy) != 0)
+	_xa_surface_handle(src_vpix->hw, &vsaa->src_handle, &dummy) != 0)
 	return FALSE;
 
     REGION_NULL(pScreen, &vsaa->present_region);
@@ -856,7 +870,7 @@ vmwgfx_copy_prepare(struct saa_driver *driver,
     Bool has_valid_hw;
 
     if (!vsaa->xat || !SAA_PM_IS_SOLID(&dst_pixmap->drawable, plane_mask) ||
-	alu != GXcopy)
+	alu != GXcopy || !vsaa->is_master)
 	return FALSE;
 
     src_vpix = vmwgfx_saa_pixmap(src_pixmap);
@@ -929,6 +943,7 @@ vmwgfx_copy_prepare(struct saa_driver *driver,
 
 	if (!vmwgfx_hw_validate(src_pixmap, src_reg)) {
 	    xa_copy_done(vsaa->xa_ctx);
+	    xa_context_flush(vsaa->xa_ctx);
 	    return FALSE;
 	}
 
@@ -1029,6 +1044,7 @@ vmwgfx_copy_done(struct saa_driver *driver)
 	return;
     }
     xa_copy_done(vsaa->xa_ctx);
+    xa_context_flush(vsaa->xa_ctx);
 }
 
 static Bool
@@ -1051,6 +1067,9 @@ vmwgfx_composite_prepare(struct saa_driver *driver, CARD8 op,
     RegionRec empty;
     struct xa_composite *xa_comp;
 
+    if (!vsaa->is_master)
+	return FALSE;
+
     REGION_NULL(pScreen, &empty);
 
     /*
@@ -1175,6 +1194,7 @@ vmwgfx_composite_done(struct saa_driver *driver)
    struct vmwgfx_saa *vsaa = to_vmwgfx_saa(driver);
 
    xa_composite_done(vsaa->xa_ctx);
+   xa_context_flush(vsaa->xa_ctx);
 }
 
 static void
@@ -1209,7 +1229,7 @@ vmwgfx_operation_complete(struct saa_driver *driver,
      */
 
     if (vpix->hw && vpix->hw_is_dri2_fronts) {
-	if (1 && pScrn->vtSema &&
+	if (pScrn->vtSema &&
 	    vmwgfx_upload_to_hw(driver, pixmap, &spix->dirty_shadow)) {
 
 	    REGION_EMPTY(vsaa->pScreen, &spix->dirty_shadow);
@@ -1360,7 +1380,9 @@ vmwgfx_saa_init(ScreenPtr pScreen, int drm_fd, struct xa_tracker *xat,
     vsaa->use_present_opt = direct_presents;
     vsaa->only_hw_presents = only_hw_presents;
     vsaa->rendercheck = rendercheck;
+    vsaa->is_master = TRUE;
     WSBMINITLISTHEAD(&vsaa->sync_x_list);
+    WSBMINITLISTHEAD(&vsaa->pixmaps);
 
     vsaa->driver = vmwgfx_saa_driver;
     vsaa->vcomp = vmwgfx_alloc_composite();
@@ -1436,7 +1458,7 @@ vmwgfx_scanout_ref(struct vmwgfx_screen_entry  *entry)
 	     */
 	    if (!vmwgfx_hw_accel_validate(pixmap, 0, XA_FLAG_SCANOUT, 0, NULL))
 		goto out_err;
-	    if (xa_surface_handle(vpix->hw, &handle, &dummy) != 0)
+	    if (_xa_surface_handle(vpix->hw, &handle, &dummy) != 0)
 		goto out_err;
 	    depth = xa_format_depth(xa_surface_format(vpix->hw));
 
@@ -1510,3 +1532,34 @@ vmwgfx_scanout_unref(struct vmwgfx_screen_entry *entry)
     entry->pixmap = NULL;
     pixmap->drawable.pScreen->DestroyPixmap(pixmap);
 }
+
+void
+vmwgfx_saa_set_master(ScreenPtr pScreen)
+{
+    struct vmwgfx_saa *vsaa = to_vmwgfx_saa(saa_get_driver(pScreen));
+
+    vsaa->is_master = TRUE;
+}
+
+void
+vmwgfx_saa_drop_master(ScreenPtr pScreen)
+{
+    struct vmwgfx_saa *vsaa = to_vmwgfx_saa(saa_get_driver(pScreen));
+    struct _WsbmListHead *list;
+    struct vmwgfx_saa_pixmap *vpix;
+    struct saa_pixmap *spix;
+
+    WSBMLISTFOREACH(list, &vsaa->pixmaps) {
+	vpix = WSBMLISTENTRY(list, struct vmwgfx_saa_pixmap, pixmap_list);
+	spix = &vpix->base;
+
+	if (!vpix->hw)
+	    continue;
+
+	(void) vmwgfx_download_from_hw(&vsaa->driver, spix->pixmap,
+				       &spix->dirty_hw);
+	REGION_EMPTY(draw->pScreen, &spix->dirty_hw);
+    }
+
+    vsaa->is_master = FALSE;
+}
diff --git a/vmwgfx/vmwgfx_saa.h b/vmwgfx/vmwgfx_saa.h
index bb8ec96..5e1f40c 100644
--- a/vmwgfx/vmwgfx_saa.h
+++ b/vmwgfx/vmwgfx_saa.h
@@ -54,6 +54,7 @@ struct vmwgfx_saa_pixmap {
     int hw_is_dri2_fronts;
     struct _WsbmListHead sync_x_head;
     struct _WsbmListHead scanout_list;
+    struct _WsbmListHead pixmap_list;
 
     uint32_t xa_flags;
     uint32_t staging_add_flags;
@@ -107,4 +108,23 @@ Bool
 vmwgfx_hw_accel_validate(PixmapPtr pixmap, unsigned int depth,
 			 uint32_t add_flags, uint32_t remove_flags,
 			 RegionPtr region);
+
+void
+vmwgfx_saa_set_master(ScreenPtr pScreen);
+
+void
+vmwgfx_saa_drop_master(ScreenPtr pScreen);
+
+#if (XA_TRACKER_VERSION_MAJOR <= 1) && !defined(HAVE_XA_2)
+
+#define _xa_surface_handle(_a, _b, _c) xa_surface_handle(_a, _b, _c)
+#define xa_context_flush(_a)
+
+#else
+
+#define xa_surface_destroy(_a) xa_surface_unref(_a)
+#define _xa_surface_handle(_a, _b, _c)		\
+    xa_surface_handle(_a, xa_handle_type_shared, _b, _c)
+
+#endif /*  (XA_TRACKER_VERSION_MAJOR <= 1) */
 #endif
diff --git a/vmwgfx/vmwgfx_saa_priv.h b/vmwgfx/vmwgfx_saa_priv.h
index 5f46dee..16583b0 100644
--- a/vmwgfx/vmwgfx_saa_priv.h
+++ b/vmwgfx/vmwgfx_saa_priv.h
@@ -54,8 +54,10 @@ struct vmwgfx_saa {
     Bool use_present_opt;
     Bool only_hw_presents;
     Bool rendercheck;
+    Bool is_master;
     void (*present_flush) (ScreenPtr pScreen);
     struct _WsbmListHead sync_x_list;
+    struct _WsbmListHead pixmaps;
     struct vmwgfx_composite *vcomp;
 };
 
diff --git a/vmwgfx/vmwgfx_tex_video.c b/vmwgfx/vmwgfx_tex_video.c
index 449266b..9fd8f22 100644
--- a/vmwgfx/vmwgfx_tex_video.c
+++ b/vmwgfx/vmwgfx_tex_video.c
@@ -70,11 +70,11 @@ static const float bt_709[] = {
 static Atom xvBrightness, xvContrast, xvSaturation, xvHue;
 
 #define NUM_TEXTURED_ATTRIBUTES 4
-static XF86AttributeRec TexturedAttributes[NUM_TEXTURED_ATTRIBUTES] = {
-   {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
-   {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
-   {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
-   {XvSettable | XvGettable, -1000, 1000, "XV_HUE"}
+static const XF86AttributeRec TexturedAttributes[NUM_TEXTURED_ATTRIBUTES] = {
+    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
+    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
+    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
+    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"}
 };
 
 #define NUM_FORMATS 3
@@ -82,7 +82,7 @@ static XF86VideoFormatRec Formats[NUM_FORMATS] = {
    {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
 };
 
-static XF86VideoEncodingRec DummyEncoding[1] = {
+static const XF86VideoEncodingRec DummyEncoding[1] = {
    {
       0,
       "XV_IMAGE",
@@ -111,8 +111,7 @@ struct xorg_xv_port_priv {
     int hue;
 
     int current_set;
-    struct vmwgfx_dmabuf *bounce[2][3];
-    struct xa_surface *yuv[3];
+    struct xa_surface *yuv[2][3];
 
     int drm_fd;
 
@@ -198,14 +197,10 @@ stop_video(ScrnInfoPtr pScrn, pointer data, Bool shutdown)
        priv->fence = NULL;
 
        for (i=0; i<3; ++i) {
-	   if (priv->yuv[i]) {
-	       xa_surface_destroy(priv->yuv[i]);
-	       priv->yuv[i] = NULL;
-	   }
 	   for (j=0; j<2; ++j) {
-	       if (priv->bounce[j][i]) {
-		   vmwgfx_dmabuf_destroy(priv->bounce[j][i]);
-		   priv->bounce[0][i] = NULL;
+	       if (priv->yuv[i]) {
+		   xa_surface_destroy(priv->yuv[j][i]);
+		   priv->yuv[j][i] = NULL;
 	       }
 	   }
        }
@@ -297,11 +292,9 @@ static int
 check_yuv_surfaces(struct xorg_xv_port_priv *priv,  int id,
 		   int width, int height)
 {
-    struct xa_surface **yuv = priv->yuv;
-    struct vmwgfx_dmabuf **bounce = priv->bounce[priv->current_set];
+    struct xa_surface **yuv = priv->yuv[priv->current_set];
     int ret = 0;
     int i;
-    size_t size;
 
     for (i=0; i<3; ++i) {
 
@@ -334,19 +327,6 @@ check_yuv_surfaces(struct xorg_xv_port_priv *priv,  int id,
 	if (ret || !yuv[i])
 	    return BadAlloc;
 
-	size = width * height;
-
-	if (bounce[i] && (bounce[i]->size < size ||
-			  bounce[i]->size > 2*size)) {
-	    vmwgfx_dmabuf_destroy(bounce[i]);
-	    bounce[i] = NULL;
-	}
-
-	if (!bounce[i]) {
-	    bounce[i] = vmwgfx_dmabuf_alloc(priv->drm_fd, size);
-	    if (!bounce[i])
-		return BadAlloc;
-	}
     }
     return Success;
 }
@@ -413,28 +393,20 @@ copy_packed_data(ScrnInfoPtr pScrn,
                  unsigned short w, unsigned short h)
 {
     int i;
-   struct vmwgfx_dmabuf **bounce = port->bounce[port->current_set];
+   struct xa_surface **yuv = port->yuv[port->current_set];
    char *ymap, *vmap, *umap;
    unsigned char y1, y2, u, v;
    int yidx, uidx, vidx;
    int y_array_size = w * h;
    int ret = BadAlloc;
 
-   /*
-    * Here, we could use xa_surface_[map|unmap], but given the size of
-    * the yuv textures, that could stress the xa tracker dma buffer pool,
-    * particularaly with multiple videos rendering simultaneously.
-    *
-    * Instead, cheat and allocate vmwgfx dma buffers directly.
-    */
-
-   ymap = (char *)vmwgfx_dmabuf_map(bounce[0]);
+   ymap = xa_surface_map(port->r, yuv[0], XA_MAP_WRITE);
    if (!ymap)
        return BadAlloc;
-   umap = (char *)vmwgfx_dmabuf_map(bounce[1]);
+   umap = xa_surface_map(port->r, yuv[1], XA_MAP_WRITE);
    if (!umap)
        goto out_no_umap;
-   vmap = (char *)vmwgfx_dmabuf_map(bounce[2]);
+   vmap = xa_surface_map(port->r, yuv[2], XA_MAP_WRITE);
    if (!vmap)
        goto out_no_vmap;
 
@@ -444,16 +416,16 @@ copy_packed_data(ScrnInfoPtr pScrn,
    switch (id) {
    case FOURCC_YV12: {
       int pitches[3], offsets[3];
-      unsigned char *y, *u, *v;
+      unsigned char *yp, *up, *vp;
       query_image_attributes(pScrn, FOURCC_YV12,
                              &w, &h, pitches, offsets);
 
-      y = buf + offsets[0];
-      v = buf + offsets[1];
-      u = buf + offsets[2];
-      memcpy(ymap, y, w*h);
-      memcpy(vmap, v, w*h/4);
-      memcpy(umap, u, w*h/4);
+      yp = buf + offsets[0];
+      vp = buf + offsets[1];
+      up = buf + offsets[2];
+      memcpy(ymap, yp, w*h);
+      memcpy(vmap, vp, w*h/4);
+      memcpy(umap, up, w*h/4);
       break;
    }
    case FOURCC_UYVY:
@@ -493,64 +465,11 @@ copy_packed_data(ScrnInfoPtr pScrn,
    }
 
    ret = Success;
-   vmwgfx_dmabuf_unmap(bounce[2]);
+   xa_surface_unmap(yuv[2]);
   out_no_vmap:
-   vmwgfx_dmabuf_unmap(bounce[1]);
+   xa_surface_unmap(yuv[1]);
   out_no_umap:
-   vmwgfx_dmabuf_unmap(bounce[0]);
-
-   if (ret == Success) {
-       struct xa_surface *srf;
-       struct vmwgfx_dmabuf *buf;
-       uint32_t handle;
-       unsigned int stride;
-       BoxRec box;
-       RegionRec reg;
-
-       box.x1 = 0;
-       box.x2 = w;
-       box.y1 = 0;
-       box.y2 = h;
-
-       REGION_INIT(pScrn->pScreen, &reg, &box, 1);
-
-       for (i=0; i<3; ++i) {
-	   srf = port->yuv[i];
-	   buf = bounce[i];
-
-	   if (i == 1) {
-	       switch(id) {
-	       case FOURCC_YV12:
-		   h /= 2;
-		   /* Fall through */
-	       case FOURCC_YUY2:
-	       case FOURCC_UYVY:
-		   w /= 2;
-		   break;
-	       default:
-		   break;
-	       }
-
-	       box.x1 = 0;
-	       box.x2 = w;
-	       box.y1 = 0;
-	       box.y2 = h;
-
-	       REGION_RESET(pScrn->pScreen, &reg, &box);
-	   }
-
-	   if (xa_surface_handle(srf, &handle, &stride) != 0) {
-	       ret = BadAlloc;
-	       break;
-	   }
-
-	   if (vmwgfx_dma(0, 0, &reg, buf, w, handle, 1) != 0) {
-	       ret = BadAlloc;
-	       break;
-	   }
-       }
-       REGION_UNINIT(pScrn->pScreen, &reg);
-   }
+   xa_surface_unmap(yuv[0]);
 
    return ret;
 }
@@ -609,7 +528,8 @@ display_video(ScreenPtr pScreen, struct xorg_xv_port_priv *pPriv, int id,
 				 (struct xa_box *)REGION_RECTS(dstRegion),
 				 REGION_NUM_RECTS(dstRegion),
 				 pPriv->cm,
-				 vpix->hw, pPriv->yuv);
+				 vpix->hw,
+				 pPriv->yuv[pPriv->current_set ]);
 
    saa_pixmap_dirty(pPixmap, TRUE, dstRegion);
    DamageRegionProcessPending(&pPixmap->drawable);
diff --git a/vmwgfx/vmwgfx_xa_surface.c b/vmwgfx/vmwgfx_xa_surface.c
index 8b30e45..2f23c57 100644
--- a/vmwgfx/vmwgfx_xa_surface.c
+++ b/vmwgfx/vmwgfx_xa_surface.c
@@ -362,6 +362,12 @@ vmwgfx_hw_accel_validate(PixmapPtr pixmap, unsigned int depth,
 Bool
 vmwgfx_hw_dri2_validate(PixmapPtr pixmap, unsigned int depth)
 {
+    struct vmwgfx_saa *vsaa =
+	to_vmwgfx_saa(saa_get_driver(pixmap->drawable.pScreen));
+
+    if (!vsaa->is_master)
+	    return FALSE;
+
     return (vmwgfx_hw_dri2_stage(pixmap, depth) &&
 	    vmwgfx_hw_commit(pixmap) &&
 	    vmwgfx_hw_validate(pixmap, NULL));
